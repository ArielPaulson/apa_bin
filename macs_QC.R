#!/usr/bin/env Rscript

drop.mito <- TRUE  # drop mitochondrial peaks
top.pct <- 1       # top 1% peaks by height will be called "top"
cat.n <- 10        # set size for CAT plot
do.CAT <- TRUE     # run CAT plots?
use.DNS <- TRUE    # convert 'downsampled' to 'DNS' in sample names

arg <- commandArgs(trailing=TRUE)
alias <- arg[1]
files <- arg[2:length(arg)]  # 'files' are 1 or more macs2 peaks.xls files
filenames <- sapply(files, function(x) sub("^.*/","",sub(".macs2_peaks.xls$","",x)) )
if (use.DNS) filenames <- sub("downsampled","DNS",filenames)
N <- length(files)
rdata <- paste0(alias,".macs_QC.RData")

library(GenomicRanges)
source("/n/projects/apa/R/apa_tools.R")
options(stringsAsFactors=FALSE)

read.macs2 <- function(x) {
    y <- system(paste("head -100",x),intern=TRUE)  # assumes header is <= 100 lines
    h <- which(grepl("^chr[[:space:]]",y))[1]
    list(
        header=y[1:(h-1)],
        peaks=read.delim(x,as.is=TRUE,header=TRUE,skip=h)
    )
}

dat <- lapply(files, read.macs2)
headers <- slice.list(dat, "header")
peaks.all <- slice.list(dat, "peaks")
names(peaks.all) <- names(headers) <- filenames
for (i in 1:N) peaks.all[[i]][,10] <- sub(".macs2_peak","",peaks.all[[i]][,10])
if (drop.mito) {
    for (i in 1:N) peaks.all[[i]] <- peaks.all[[i]][!mgrepl(c("chrM","mito","MT"),peaks.all[[i]][,1]),]
}

n.all <- sapply(peaks.all,nrow)
n.all

line.item <- list(
    MacsVer=list("^# This file is generated by MACS version (.*)","character",0),
#    Command=list("^# Command line: (.*)","character",0),
    Name=list("^# name = (.*)","character",0),
    Format=list("^# format = (.*)","character",0),
    IP=list("^# ChIP-seq file = \\[(.*)\\]","character",1),
    Input=list("^# control file = \\[(.*)\\]","character",1),
    EffGenomeSize=list("^# effective genome size = (.*)","numeric",0),
    Bandwidth=list("^# band width = ([0-9]+)","numeric",0),
    MFoldMin=list("^# model fold = \\[([0-9]+), [0-9]+\\]","numeric",0),
    MFoldMax=list("^# model fold = \\[[0-9]+, ([0-9]+)\\]","numeric",0),
    PValMax=list("^# pvalue cutoff = (.*)","numeric",0),
    QValue=list("^# qvalue (.*)\\.?","character",0),
    ScaleFrom=list("^# ([^[:space:]]+) dataset will be scaled towards [^[:space:]]+ dataset\\.?","character",0),
    ScaleTo=list("^# [^[:space:]]+ dataset will be scaled towards ([^[:space:]]+) dataset\\.?","character",0),
    LambdaMin=list("^# Range for calculating regional lambda is: ([0-9]+) bps and [0-9]+ bps","numeric",0), 
    LambdaMax=list("^# Range for calculating regional lambda is: [0-9]+ bps and ([0-9]+) bps","numeric",0), 
    BroadCall=list("^# Broad region calling is (.*)","character",0), 
    TagSize=list("^# tag size is determined as ([0-9]+) bps","numeric",0), 
    IpTagsTot=list("^# total tags in treatment: ([0-9]+)","numeric",0), 
    IpTagsFilt=list("^# tags after filtering in treatment: ([0-9]+)","numeric",0), 
    IpPerPos=list("^# maximum duplicate tags at the same position in treatment = ([0-9]+)","numeric",0), 
    IpDupRate=list("^# Redundant rate in treatment: ([0-9.]+)","numeric",0), 
    InpTagsTot=list("^# total tags in control: ([0-9]+)","numeric",0), 
    InpTagsFilt=list("# tags after filtering in control:^ ([0-9]+)","numeric",0), 
    InpPerPos=list("^# maximum duplicate tags at the same position in control = ([0-9]+)","numeric",0), 
    InpDupRate=list("^# Redundant rate in control: ([0-9.]+)","numeric",0), 
    d=list("^# d = ([0-9]+)","numeric",0)
)
L <- length(line.item)

header.mat <- data.frame(do.call(rbind2, lapply(headers, function(x){ data.frame(lapply(1:L, function(i){
    li=line.item[[i]]
    w <- grep(li[[1]],x)[1]
    ifelse(length(w)>0, as(sub(li[[1]],"\\1",x[w]),li[[2]]), NA)
}), stringsAsFactors=FALSE) })), stringsAsFactors=FALSE)
dimnames(header.mat) <- list(filenames, names(line.item))
header.mat <- cbind(header.mat, PeakCalls=sapply(peaks.all,nrow))

w.all <- lapply(slice.list(peaks.all,4,"cols"),log2)   # width
h.all <- lapply(slice.list(peaks.all,6,"cols"),log2)   # height
p.all <- lapply(slice.list(peaks.all,7,"cols"),log2)   # p-val
fc.all <- lapply(slice.list(peaks.all,8,"cols"),log2)  # fold-change

vnames.all <- paste("(",n.all,") ",filenames,sep="")

png(paste(alias,"histograms.all.png",sep="."), 1500, 1000)
par(mfrow=c(2,2), cex=1.2, las=1)
dhist(w.all, points=T, vnames=vnames.all, ylab="", main="Log2 Peak Width")
dhist(h.all, points=T, vnames=vnames.all, ylab="", xmin=0, main="Log2 Peak Height")
dhist(p.all, points=T, vnames=vnames.all, ylab="", xmin=0, main="Log2 Peak P-value Magnitude")
dhist(fc.all, points=T, vnames=vnames.all, ylab="", xmin=0, main="Log2 Peak Fold-Change")
dev.off()

ht.lim <- 2^sapply(h.all, quantile, probs=1-(top.pct/100))
ht.lim

peaks.top <- lapply(1:N, function(i){ x=peaks.all[[i]][peaks.all[[i]][,6]>=ht.lim[i],]; x[order(x[,6],decreasing=TRUE),] })
names(peaks.top) <- filenames
n.top <- sapply(peaks.top,nrow)
n.top

n.top/n.all

w.top <- lapply(slice.list(peaks.top,4,"cols"),log2)   # width
h.top <- lapply(slice.list(peaks.top,6,"cols"),log2)   # height
p.top <- lapply(slice.list(peaks.top,7,"cols"),log2)   # p-val
fc.top <- lapply(slice.list(peaks.top,8,"cols"),log2)  # fold-change

vnames.top <- paste("(",n.top,") ",filenames,sep="")

png(paste(alias,"histograms.top.png",sep="."), 1500, 1000)
par(mfrow=c(2,2), cex=1.2, las=1)
dhist(w.top, points=T, vnames=vnames.top, ylab="", main=paste("Log2 Peak Width, Top ",top.pct,"% Peaks by Height",sep=""))
dhist(h.top, points=T, vnames=vnames.top, ylab="", xmin=0, main=paste("Log2 Peak Height, Top ",top.pct,"% Peaks by Height",sep=""))
dhist(p.top, points=T, vnames=vnames.top, ylab="", xmin=0, main=paste("Log2 Peak P-value Magnitude, Top ",top.pct,"% Peaks by Height",sep=""))
dhist(fc.top, points=T, vnames=vnames.top, ylab="", xmin=0, main=paste("Log2 Peak Fold-Change, Top ",top.pct,"% Peaks by Height",sep=""))
dev.off()


save.sample <- function(i) {
    w <- w.all[[i]]
    h <- h.all[[i]]
    p <- p.all[[i]]
    fc <- fc.all[[i]]
    header <- header.mat[i,]
    peaks <- peaks.all[[i]]
    save(w,h,p,fc,header,peaks, file=paste(filenames[i],"peaks.macs_QC.RData",sep="."))
}

for (i in 1:N) save.sample(i)

if (do.CAT) {

    gr.top <- lapply(peaks.top, function(x){ bed2gr(x[,c(1,2,3,10,6)]) })

    catplot <- function(i,j,n,iname,jname) {
        suppressWarnings(x <- as.matrix(findOverlaps(gr.top[[i]],gr.top[[j]])))
        a <- peaks.top[[i]][x[,1],6]
        b <- peaks.top[[j]][x[,2],6]
        names(a) <- names(b) <- paste("match",1:nrow(x),sep="")
        y <- CAT.plot(a,b,N=n,col=2,main=paste(iname,jname,sep="-"))
        lines(1:length(a), sort(a,decreasing=T)/max(a), col=3)
        lines(1:length(b), sort(b,decreasing=T)/max(b), col=4, lty=2)
        legend("right", bty="n", lty=1:2, col=3:4, legend=c(iname,jname), title="Peak Height as % Max")
        merged1 <- cbind(peaks.top[[i]][x[,1],1:3],peaks.top[[j]][x[,2],2:3])
        y$merged <- as.data.frame(merged1[,1:3])
        for (r in 1:nrow(merged1)) {
            y$merged[[2]][i] <- min(unlist(merged1[i,2:5]))
            y$merged[[3]][i] <- max(unlist(merged1[i,2:5]))
        }
        invisible(y)
    }

    combos <- combn(1:N, 2)
    dims <- MA.scatter.plotdim(ncol(combos))

    png(paste(alias,"CAT.plots.png",sep="."), dims[4], dims[3])
    par(mfrow=dims[1:2], cex=1.2, las=1)
    cat.dat <- lapply(1:ncol(combos), function(i){
        catplot(combos[1,i], combos[2,i], cat.n, filenames[combos[1,i]], filenames[combos[2,i]])
    })
    dev.off()

    for (i in 1:ncol(combos)) write.table(cbind(cat.dat[[i]]$merged,paste(alias,1:nrow(cat.dat[[i]]$merged),sep="_"),1,"+"), paste(filenames[combos[1,i]],filenames[combos[2,i]],"top_joint_peaks.bed",sep="."), sep="\t", quote=F, row.names=F, col.names=F)
}

save.image(rdata)

quit()



