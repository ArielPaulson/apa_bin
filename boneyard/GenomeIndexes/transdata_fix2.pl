#!/usr/bin/env perl
require "$ENV{SIMR_APA_BIN}/apa_routines.pm";
use Data::Dumper;
use strict;


## Expands the basic $geno.$anno.transcript_data.txt file generated by buildTranscriptome


## Envar test; core process directories
my $apabin = $ENV{SIMR_APA_BIN};
die "$0: shell environment variable \$SIMR_APA_BIN is not set!\n" unless $apabin;
my $buildroot = $ENV{SIMR_BUILDROOT};
die "$0: shell environment variable \$SIMR_BUILDROOT is not set!\n" unless $buildroot;


## Dependencies
my $gtf2fa = "$apabin/gtf2fa";


## Args
my ($geno, $anno) = @ARGV;


## Locations, prefixes, files
my $buildg = "$buildroot/builds/$geno";
my $builda = "$buildg/annotation/$anno";
my $prepg  = "$buildroot/preps/$geno";
my $prepa  = "$prepg/$anno";
my $prepf  = "$prepa/fastas";
my $chrdat = "$buildg/extras/$geno.chrom_data.txt";
my $genofa = "$buildg/$geno.fa";
my $gdat   = "$builda/tables/$geno.$anno.gene_data.txt";
my $tdati  = "$builda/tables/$geno.$anno.transcript_data.temp.txt";
my $tdatf  = "$builda/tables/$geno.$anno.transcript_data.fix.txt";
my $tdat_e = "$prepa/transcript_data_fix2.errors.txt";
my $VAR    = "$prepg/_VARIABLES";
my $TVAR   = "$prepa/_TVARIABLES";


## Expected file tests
die "$0: Transcript data file '$tdati' does not exist!\n" unless -e $tdati;
die "$0: Genome variables file '$VAR' does not exist!\n" unless -e $VAR;
die "$0: Chromosome data file '$chrdat' does not exist!\n" unless -e $chrdat;


## Temp
my $tmp = "$prepa/transcript_data_fix2.tmp";
system "rm -rf $tmp";
system "mkdir $tmp";
die "$0: failed to create temp dir '$tmp'\n" unless -d $tmp;


## Some hardcoded stuff
my @names = qw/ TransID Name GeneID Chr Start End Strand Tot_Len cDNA_Len mRNA_Len Spl_Len N_Exons Max_Intron Max_Intron Genomic_CDS_Start Genomic_CDS_End Biotype SimpleBiotype /;  # existing
my @names2 = qw/ Status Trans_CDS_Start Trans_CDS_End CDS_Len cDNA_GC CDS_GC snpEff_Codon_Table /;  # added in this script
my @names3 = qw/ TransID Name GeneID Chr Start End Strand Tot_Len cDNA_Len CDS_Len cDNA_GC CDS_GC N_Exons Max_Intron Biotype SimpleBiotype GeneBiotype GeneSimpleBiotype Status Genomic_CDS_Start Genomic_CDS_End Trans_CDS_Start Trans_CDS_End snpEff_Codon_Table /;  # new combined order
my %stops = map {($_=>1)} qw/ TAG TGA TAA /;
my %ATG_1offs = map {($_=>1)} qw/ CTG GTG TTG AAG ACG AGG ATA ATC ATT /;
my %ATG_2offs = map {($_=>1)} qw/ AAA AAC AAT ACA ACC ACT AGA AGC AGT  CTA CTC CTT GTA GTC GTT TTA TTC TTT  CAG CCG CGG GAG GCG GGG TAG TCG TGG /;


## Get genome-specific variables
chomp(my $table = `grep "^snpEff_codon" $TVAR | sed 's/snpEff_codon=//' | sed 's/ .*//'`);
chomp(my $Mtable = `grep "^snpEff_MTcodon" $TVAR | sed 's/snpEff_MTcodon=//' | sed 's/ .*//'`);
chomp(my $Mchr = `grep -P "\\tmitochondrion\\t" $chrdat | cut -f2`);   # take first name column
print "No mito in reference!\n" unless $Mchr;


## Detect GTF
my $gtf = "$builda/gtfs/$geno.$anno.gtf";
$gtf = "$builda/gtfs/$geno.$anno.cuff.gtf" unless -e $gtf;
die "$0: no GTF for $geno/$anno could be found!\n" unless -e $gtf;
print "GTF: $gtf\n";


## Detect rebuilt fastas, otherwise create them
print "Generating transcript fastas...\n";
my $rebuilt_fa = "$prepf/$geno.$anno.cdna.rebuilt.fa";         # Should be gzipped, but here we test for unzipped form first...
my $rebuilt_cds_fa = "$prepf/$geno.$anno.cdna.rebuilt-cds.fa"; # "
system "gzip -f $rebuilt_fa" if -e $rebuilt_fa;         # Compress, if wasn't already
system "gzip -f $rebuilt_cds_fa" if -e $rebuilt_cds_fa; # "
$rebuilt_fa .= ".gz";     # NOW EXPECTING GZIPPED FASTA
$rebuilt_cds_fa .= ".gz"; # NOW EXPECTING GZIPPED FASTA
my $cmd1 = "$gtf2fa $genofa $gtf $rebuilt_fa";
print "$cmd1\n";
system $cmd1; # unless -e $rebuilt_fa;      # WRITES GZIPPED
my $cmd2 = "$gtf2fa $genofa $gtf $rebuilt_cds_fa --cds\n";
print "$cmd2\n";
system $cmd2; # unless -e $rebuilt_cds_fa;  # WRITES GZIPPED

## Read in cDNA sequences
print "Reading transcript fastas...\n";
my $CDNA = &open2('R', $rebuilt_fa, 'Rebuilt cDNA fasta');
my @x = &readFasta($CDNA);
close $CDNA;
my %cdna = %{ $x[0] };
my @headers = @{ $x[1] };


## Read in CDS sequences
my $CDS = &open2('R', $rebuilt_cds_fa, 'Rebuilt CDS fasta');
my @x = &readFasta($CDS);
close $CDS;
my %cds = %{ $x[0] };


## Read gene_data.txt
print "Parsing existing gene data...\n";
my (%gbio, $bio, $sbio);
my $IN1 = &open2('R', $gdat, 'Input gene data txt');
while (<$IN1>) {
    s/[\n\r]+$//;
    my @data = split /\t/, $_;
    if ($. == 1) {
        foreach (0..$#data) {
            $bio = $_ if $data[$_] eq 'Biotype';
            $sbio = $_ if $data[$_] eq 'SimpleBiotype';
        }
    } else {
        $gbio{$data[0]} = [$data[$bio], $data[$sbio]];
    }
}
close $IN1;


## Read transcript_data.txt
print "Parsing existing transcript data...\n";
my (@colnames, %master);
my $IN2 = &open2('R', $tdati, 'Input transcript data txt');
while (<$IN2>) {
    s/[\n\r]+$//;
    my @data = split /\t/, $_;
    if ($. == 1) {
        @colnames = @data;
    } else {
        $master{$data[0]}{ $colnames[$_] } = $data[$_] foreach (0..$#colnames);
    }
}
close $IN2;


## Add gene biotypes to trans data
foreach my $trans (keys %master) {
    $master{$trans}{GeneBiotype} = $gbio{ $master{$trans}{GeneID} }->[0];
    $master{$trans}{GeneSimpleBiotype} = $gbio{ $master{$trans}{GeneID} }->[1];
}


## Get 'Status' field for transcripts (if possible; Ensembl has deprecated gene status at of v87 it seems?)
## All that code below just to get one value!
my $cdnafa = (glob "$prepf/*.cdna.all.fa")[0];  # Again, expects gzipped, but test for unzipped first
my $ncrnafa = (glob "$prepf/*.ncrna.fa")[0];    # "
if (-e $cdnafa) {
    system "gzip -f $cdnafa";
    $cdnafa .= '.gz';  # NOW EXPECTS GZIPPED
} else {
    $cdnafa = (glob "$prepf/*.cdna.all.fa.gz")[0];
}
if (-e $ncrnafa) {
    system "gzip -f $ncrnafa";
    $ncrnafa .= '.gz'; # "
} else {
    $ncrnafa = (glob "$prepf/*.ncrna.fa.gz")[0];
}
my @ensfa = ($cdnafa, $ncrnafa);
foreach my $i (0, 1) {
    unless (-e $ensfa[$i]) {
        my $enstype = $i ? 'ncRNA' : 'cDNA';
        print "WARNING: Ensembl $enstype fasta not detected!  Continuing...\n";
        next;
    }
    print "zcat $ensfa[$i] | grep \"^>\" | cut -f1-2 -d' ' |\n";
    open TH, "zcat $ensfa[$i] | grep \"^>\" | cut -f1-2 -d' ' |";
    while (<TH>) {
        chomp;
        my ($header, $stat) = split;
        $header =~ s/^>//;
        $stat =~ s/^[^:]+://;
        $master{$header}{Status} = "\U$stat";
    }
    close TH;
}


## Process datasets and expand transcript_data.txt
print "Generating new transcript data...\n";
my (@test, %off, %stats, %errors);
my $N = scalar @headers;
my ($n, $C, $NC);
foreach my $header (@headers) {
    print "$n: $header\n" if $header =~ /^ACACAC/;
    $n++;
    print " $n/$N\n" if $n % 1000 == 0;
    $master{$header}{cDNA_Len} = $master{$header}{Spl_Len} if exists $master{$header}{Spl_Len};  # old colname mapping
    $master{$header}{cDNA_Len} = $master{$header}{mRNA_Len} if exists $master{$header}{mRNA_Len};  # old colname mapping
    $master{$header}{Max_Intron} = $master{$header}{MaxIntron} if exists $master{$header}{MaxIntron};  # old colname mapping
    my (%x, $is_pc);
    if ($master{$header}{SimpleBiotype}) {
        $is_pc = $master{$header}{SimpleBiotype} eq 'protein_coding';
    } else {
        die "$0: no SimpleBiotype defined for transcript '$header'!\n";
    }
    my $thistable = !$is_pc ? '' : $master{$header}{Chr} eq $Mchr ? $Mtable : $table;
    $master{$header}{snpEff_Codon_Table} = $thistable;
    my $ucdna = "\U$cdna{$header}";
    my $cdnal = length($ucdna);
    #print "$header CDNA length obs/exp = $cdnal/$master{$header}{cDNA_Len}\n" if $cdnal != $master{$header}{cDNA_Len};
    if ($cdnal > $master{$header}{cDNA_Len}) {
        $stats{LEN}{over}++;
        $errors{LEN}{over}{$header} = 1;
    } elsif ($cdnal < $master{$header}{cDNA_Len}) {
        $stats{LEN}{under}++;
        $errors{LEN}{under}{$header} = 1;
    } else {
        $stats{LEN}{equal}++;
    }
    $x{cdna}{$_}++ foreach split //, $ucdna;
    my $gc = $x{cdna}{G}+$x{cdna}{C};
    my $ACGTsum = $x{cdna}{A}+$x{cdna}{C}+$x{cdna}{G}+$x{cdna}{T};
    #print "$header cDNA sequence has no A, C, G, or T!\n" unless $ACGTsum;
    unless ($ACGTsum) {
        $stats{NOACGT}{cdna}++;
        $errors{NOACGT}{cdna}{$header} = 1;
    }
    $master{$header}{cDNA_GC} = sprintf("%0.2f", 100*$gc/($ACGTsum||1));  # excluding Ns; GC as % observable NTs
    if ($is_pc) {
        $C++;
        if (exists $cds{$header}) {
            my $ucds = "\U$cds{$header}";
            if ($ucds =~ /^ATG/) {
                $stats{ORF5}{ATG}++;
            } elsif ($ATG_1offs{ substr($ucds,0,3) }) {
                $stats{ORF5}{'1off'}++;
                $errors{ORF5}{'1off'}{$header} = 1;
            } else {
                $stats{ORF5}{none}++;
                $errors{ORF5}{none}{$header} = 1;
            }
            my $ucdl = length($ucds);
            my $codons = sprintf("%0.1f", $ucdl/3);
            #print "$header CDS length $ucdl is $codons codons!\n" if $ucdl % 3 > 0;
            my $orfmod = $ucdl % 3;
            $stats{MOD}{$orfmod}++;
            $errors{MOD}{$orfmod}{$header} = 1 if $orfmod != 0;
            $x{cds}{$_}++ foreach split //, $ucds;
            my $gc2 = $x{cds}{G}+$x{cds}{C};
            my $ACGTsum2 = $x{cds}{A}+$x{cds}{C}+$x{cds}{G}+$x{cds}{T};
            #print "$header CDS sequence has no A, C, G, or T!\n" unless $ACGTsum2;
            unless ($ACGTsum2) {
                $stats{NOACGT}{cds}++;
                $errors{NOACGT}{cds}{$header} = 1;
            }
            $master{$header}{CDS_GC} = sprintf("%0.2f", 100*$gc2/($ACGTsum2||1));  # excluding Ns; GC as % observable NTs
            $master{$header}{CDS_Len} = $ucdl;
            my $cstart = index($ucdna, $ucds);
            if ($cstart > -1) {
                ## CDS placed via index()
                $master{$header}{Trans_CDS_Start} = $cstart+1;
                $master{$header}{Trans_CDS_End} = $cstart+$ucdl;
                $stats{CDS}{index}++;
                if ($stops{ substr($ucdna, $cstart+$ucdl, 3) }) {
                    $stats{ORF3}{out}++;
                } elsif ($ucds =~ /(TAG|TGA|TAA)$/) {
                    $stats{ORF3}{in}++;
                    $errors{ORF3}{in}{$header} = 1;
                } else {
                    $stats{ORF3}{none}++;
                    $errors{ORF3}{none}{$header} = 1;
                }
            } else {
                ## CDS placed via blat (or not...)
                print "Blatting $header...\n";
                my $q = "$tmp/$header.q";
                my $t = "$tmp/$header.t";
                system "echo -e \">CDS\n$ucds\" > $q.fa";
                system "echo -e \">CDNA\n$ucdna\" > $t.fa";
                system "blat -noHead $t.fa $q.fa $q.psl > /dev/null";
                open PSL, "$q.psl";
                my (@recs, %tmp, @final);
                while (<PSL>) {
                    push @recs, $_;
                    chomp;
                    my @data = split /\t/, $_;
                    $tmp{$data[0]} = \@data;  # store record by N matches (will overwrite any existing alignment of same length, so hopefully only one longest exists...)
                }
                if ($. == 0) {
                    ## no alignments??
                    #print "$header CDS blat returned no matches!\n";
                    $master{$header}{Trans_CDS_Start} = $master{$header}{Trans_CDS_End} = '';
                    #print "\n$header $master{$header}{Name} $master{$header}{Biotype} CDS ($master{$header}{CDS_Len})\n               CDS: $ucds\n               CDNA: $ucdna\n\n";
                    $stats{CDS}{blat0}++;
                    $errors{CDS}{blat0}{$header} = 1;
                    next;
                } elsif ($. == 1) {
                    ## expecting only one CDS-CDNA alignment
                    @final = @{ $tmp{(keys %tmp)[0]} };  # only one record
                    $stats{CDS}{blat1}++;
                    $errors{CDS}{blat1}{$header} = 1;
                } else {
                    ## got multiple CDS->CDNA alignments
                    my $best = (sort {$b <=> $a} keys %tmp)[0];  # largest N maatches
                    @final = @{ $tmp{$best} };  # record with largest N matches
                    #print "$header CDS blat returned $. matches! ($best best)\n";
                    #print @recs;
                    $stats{CDS}{blatM}++;
                    $errors{CDS}{blatM}{$header} = 1;
                }
                close PSL;
                my ($match, $mis, $rep, $N, $qgaps, $qgapbp, $tgaps, $tgapbp, $strand, $qname, $qlen, $qstart, $qend, $tname, $tlen, $tstart, $tend, $nblocks, $blocksizes, $qstarts, $tstarts) = @final;
                if ($strand ne '+') {
                    ## expecting CDS and CDNA were both in sense orientation??
                    print "$header CDS blat is on wrong strand!\n";
                    $stats{CDS}{blatrev}++;
                    $errors{CDS}{blatrev}{$header} = 1;
                }
                if ($nblocks > 1) {
                    ## expecting contiguous CDS-CDNA alignment
                    print "$header CDS blat has $nblocks blocks!\n";
                    $stats{CDS}{blatgap}++;
                    $errors{CDS}{blatgap}{$header} = 1;
                }
                my $qflank5 = $qstart;
                my $qflank3 = $qlen-$qend;
                $master{$header}{Trans_CDS_Start} = $tstart + 1 - $qflank5;  # shift to 1-based
                $master{$header}{Trans_CDS_End} = $tend + $qflank3;
                if ($stops{ substr($ucdna, $tend+$qflank3, 3) }) {
                    $stats{ORF3}{out}++;
                } elsif ($ucds =~ /(TAG|TGA|TAA)$/) {
                    $stats{ORF3}{in}++;
                    $errors{ORF3}{in}{$header} = 1;
                } else {
                    $stats{ORF3}{none}++;
                    $errors{ORF3}{none}{$header} = 1;
                }
                #my $blatlen = $master{$header}{Trans_CDS_End} - $master{$header}{Trans_CDS_Start} + 1;
                #my $codons2 = sprintf("%0.1f", $blatlen/3);
                #print "$header CDS blat coordinates are not in frame! ($tstart, $tend, $qflank5, $qflank3, $qlen, $blatlen, $codons2)\n" if $blatlen % 3 > 0;  # IGNORE: turns out, many input CDSs aren't in frame either
            }
        } else {
            #print "$header is protein_coding but no CDS sequence exists!\n";
            $stats{CDS}{nocds}++;
            $errors{CDS}{nocds}{$header} = 1;
        }
    } else {
        $NC++;
        $master{$header}{CDS_GC} = 0;
        $master{$header}{CDS_Len} = 0;
        $master{$header}{Trans_CDS_Start} = '';
        $master{$header}{Trans_CDS_End} = '';
    }
}


## Write new transcript_data.txt file and transcriptwise errors file
print "Writing outputs...\n";
my $OUT = &open2('W', $tdatf, 'Output transcript data txt'); 
print $OUT join("\t", @names3), "\n";
foreach my $header (@headers) {
    print $OUT join("\t", map { $master{$header}{$_} } @names3), "\n";
}
close $OUT;


## Write error log
my $ERR = &open2('W', $tdat_e, 'Output transcript errors txt');
print $ERR "KEY\tVALUE\tTRANS\tSYMB\tGENE\tCHR\tBIOTYPE\n";
foreach my $key (sort keys %errors) {
    foreach my $value (sort keys %{ $errors{$key} }) {
        foreach my $trans (sort keys %{ $errors{$key}{$value} }) {
            my ($name, $gene, $chr, $biotype) = map { $master{$trans}{$_} } qw/ Name GeneID Chr Biotype /;
            print $ERR join("\t", $key, $value, $trans, $name, $gene, $chr, $biotype), "\n";
        }
    }
}
close $ERR;


## Run statistics
my $Nw = length($N);
my $fmt = '%-18s:  %'.$Nw.'i  %6.2f'."%\n";
print "\nSTATS:\n";
print sprintf('Total  = %'.$Nw."i\n",$N);
print sprintf('Coding = %'.$Nw.'i (%0.2f'."%)\n",$C,100*$C/$N);
print sprintf('Noncod = %'.$Nw.'i (%0.2f'."%)\n",$NC,100*$NC/$N);
print sprintf( $fmt, "No ACTG in cDNA", ($stats{NOACGT}{cdna}||0), 100*$stats{NOACGT}{cdna}/$N );
print sprintf( $fmt, "No ACTG in CDS",  ($stats{NOACGT}{cds}||0), 100*$stats{NOACGT}{cds}/($C||1) );
print sprintf( $fmt, "Fasta len : $_",  ($stats{LEN}{$_}||0), 100*$stats{LEN}{$_}/$N ) foreach qw/ equal over under /;
print sprintf( $fmt, "CDS placed: $_",  ($stats{CDS}{$_}||0), 100*$stats{CDS}{$_}/($C||1) ) foreach qw/ index blat1 blatM blat0 rev gap nocds /;
print sprintf( $fmt, "Codon over: $_",  ($stats{MOD}{$_}||0), 100*$stats{MOD}{$_}/($C||1) ) foreach 0..2;
print sprintf( $fmt, "ORF start : $_",  ($stats{ORF5}{$_}||0), 100*$stats{ORF5}{$_}/($C||1) ) foreach qw/ ATG 1off none /;
print sprintf( $fmt, "ORF stop  : $_",  ($stats{ORF3}{$_}||0), 100*$stats{ORF3}{$_}/($C||1) ) foreach qw/ out in none /;

print "No protein-coding genes!!!\n" if $NC==$N;
print "$C (PC) + $NC (NC) != $N (TOTAL) !\n" if $C+$NC!=$N;


## Exit
print "$0 Complete!\n";
exit;

