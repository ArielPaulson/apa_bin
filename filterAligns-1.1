#!/usr/bin/env perl
use Getopt::Long;
use Pod::Usage;
use strict;

my @types = qw/ blast wublast blat exonerate sam transfac miranda /;
my %types = map {($_=>1)} @types;
my $mnames = join ', ', @types;
my $returnN = 1;
my ($alignfile, $queryfa, $subjfa, $type, $more, $self, $qlen, $slen, $lost, $outprefix, $tabular);
my ($bystrand, $noanti, $best, $topN, $pairbest, $gapless, $MinIdtBp);  # filters
my ($gaptestlast, $leastgaps, $mostgaps);  # $best-activated generic gap filters
my ($AQMinIdt, $TQMinIdt, $QMinLen, $QMinSim, $QMinBp, $QMaxGaps, $QMaxGapBp, $QMinGaps, $QMinGapBp);  # query filters
my ($ASMinIdt, $TSMinIdt, $SMinLen, $SMinSim, $SMinBp, $SMaxGaps, $SMaxGapBp, $SMinGaps, $SMinGapBp);  # subject filters
my ($AMinGaps, $AMinGapBp, $AMaxGaps, $AMaxGapBp);  # combined gap filters

GetOptions(

    "f=s"=>\$alignfile,       # alignment output; blast must use '-m 8'; wublast must use '-mformat 2'; exonerate must use '--est2genome'.  Transfac ignores everything except -t, -q, -o.
    "q=s"=>\$queryfa,         # blast query fasta
    "s=s"=>\$subjfa,          # blast subject fasta (optional)
    "t=s"=>\$type,            # type of alignment: see @types above
    "o=s"=>\$outprefix,       # prefix for output files ($outprefix.filtered, $outprefix.lost, etc).  Default = '$alignfile'
    "n=s"=>\$returnN,         # only if using --best: return results for N best scores per query (default 1)
    
    "more"=>\$more,           # output more alignment stats (appended to each input line)
    "self"=>\$self,           # this was a self-blast (query.fa vs query.fa) so ignore self-self alignments
    "qlen"=>\$qlen,           # queries have length as final header field (saves a bit of calculating, esp. if query.fa is not available)
    "slen"=>\$slen,           # subjects have length as final header field (saves a bit of calculating, esp. if subject.fa is not available)
    "bystrand"=>\$bystrand,   ############# not implemented yet: keeps best alignment for each strand, not just one absolute best alignment
    "noanti"=>\$noanti,       # ignore antisense alignments
    "gapless"=>\$gapless,     # ignore alignments with any gaps (query or subject)
    "best"=>\$best,           # do not simply filter alignments: return ONLY the best alignment(s) for each query.  See definition of 'best' below.
#    "topN"=>\$topN,           # extended $best: returns $topN-best scores.  Running $best alone is equivalent to $topN = 1.
    "pairbest"=>\$pairbest,   # like 'best', but returns best alignment per query-subject pair
    "lost"=>\$lost,           # return a fasta file of unaligned queries to $outprefix.lost
    "tabular"=>\$tabular,     # FOR MIRANDA: if using filter only (not best), return tabular output instead of raw // FOR TRANSFAC: return tabular output instead of raw
    
    "gaptestlast"=>\$gaptestlast, # only if $best: apply gap tests post-filter instead of in-line.  See definition of 'best' below.
    "leastgaps"=>\$leastgaps,     # only if $best: if multiple top-scoring alignments, prefer those with least gaps
    "mostgaps"=>\$mostgaps,       # only if $best: if multiple top-scoring alignments, prefer those with most gaps
    
    "MinIdtBp=i"=>\$MinIdtBp,    # minimum alignment identities                           |  positive integer
    
    "AQMinIdt=f"=>\$AQMinIdt,    # minimum alignment identity percent (WRT query)         |  percent on (0,1]
    "TQMinIdt=f"=>\$TQMinIdt,    # minimum total identity percent (over entire query)     |  percent on (0,1]
    "QMinLen=f"=>\$QMinLen,      # minimum alignment length percent (over entire query)   |  percent on (0,1]
    "QMinBp=i"=>\$QMinBp,        # minimum alignment length (WRT query)                   |  positive integer
    "QMinSim=f"=>\$QMinSim,      # minimum similarity percent (over entire query)         |  percent on (0,1]  (REQUIRES '$more')
    
    "ASMinIdt=f"=>\$ASMinIdt,    # minimum alignment identity percent (WRT subject)       |  percent on (0,1]
    "TSMinIdt=f"=>\$TSMinIdt,    # minimum total identity percent (over entire subject)   |  percent on (0,1]
    "SMinLen=f"=>\$SMinLen,      # minimum alignment length percent (over entire subject) |  percent on (0,1]
    "SMinBp=i"=>\$SMinBp,        # minimum alignment length (WRT subject)                 |  positive integer
    "SMinSim=f"=>\$SMinSim,      # minimum similarity percent (over entire subject)       |  percent on (0,1]  (REQUIRES '$more')
    
    "QMinGaps=i"=>\$QMinGaps,    # minimum number of gaps allowed in query                |  positive integer
    "QMaxGaps=i"=>\$QMaxGaps,    # maximum number of gaps allowed in query                |  positive integer
    "QMinGapBp=i"=>\$QMinGapBp,  # minimum width of all gaps allowed in query             |  positive integer
    "QMaxGapBp=i"=>\$QMaxGapBp,  # maximum width of all gaps allowed in query             |  positive integer
    
    "SMinGaps=i"=>\$SMinGaps,    # minimum number of gaps allowed in subject              |  positive integer
    "SMaxGaps=i"=>\$SMaxGaps,    # maximum number of gaps allowed in subject              |  positive integer
    "SMinGapBp=i"=>\$SMinGapBp,  # minimum width of all gaps allowed in subject           |  positive integer
    "SMaxGapBp=i"=>\$SMaxGapBp,  # maximum width of all gaps allowed in subject           |  positive integer
    
    "AMinGaps=i"=>\$AMinGaps,    # minimum number of ALL gaps allowed for alignment       |  positive integer
    "AMaxGaps=i"=>\$AMaxGaps,    # maximum number of ALL gaps allowed for alignment       |  positive integer
    "AMinGapBp=i"=>\$AMinGapBp,  # minimum width of ALL gaps allowed for alignment        |  positive integer
    "AMaxGapBp=i"=>\$AMaxGapBp   # maximum width of ALL gaps allowed for alignment        |  positive integer
    
    );

### THE DEFINITION OF '$best':
###
### Currently, 'best' alignments are calculated as follows:
### 1. Generally, all filters are applied in-line as file is read.  Gap tests may or may not be applied in-line -- see below.
### 2. For each query, all alignments are stored by 'score'.  For blast this is score, for wublast this is rawscore, and for the others it is the number of identities.
### 3. For each query, all alignments sharing the highest 'score' are returned.
###
### Gap handling changes with '$gaptestlast', which is OFF by default:
### 1. The idea is whether alignments which should be ignored, due to unacceptable gaps, should still be allowed to compete for "best" status.
### 2. If "on", the ONLY gap tests applied in-line are for gaplessness.  Thus if $gapless==1 (for instance) all gapped alignments are barred from consideration.
###    The remainder of gap tests are applied AFTER top-score selection.  This way, if the BEST alignment still fails gap filtering, then NO alignments will be reported.
### 3. If "off", all gap tests are applied in-line, and the top-scoring alignments are taken from the alignments which pass.
###    This fails fewer queries, but in some cases the "best" alignments you get will be weak, because the *real* best alignments were ignored, due to gaps.  Instead you are getting the "best of the rest".

die "$0: Unsupported format '$type': must be one of '$mnames'\n" unless $types{$type};

my $valfail;
## value on (0,1] tests
my @vars = qw/ AQMinIdt TQMinIdt QMinLen QMinSim ASMinIdt TSMinIdt SMinLen SMinSim /;
my @vals = ($AQMinIdt, $TQMinIdt, $QMinLen, $QMinSim, $ASMinIdt, $TSMinIdt, $SMinLen, $SMinSim);
foreach my $i (0..$#vars) {
    next unless defined $vals[$i];
    if ($vals[$i] <= 0 || $vals[$i] > 1) {
	$valfail = 1;
	print "$0: Parameter '$vars[$i]' value '$vals[$i]' is outside allowed range (0,1]!\n";
    }
}
## value is positive integer tests    
my @vars = qw/ MinIdtBp QMinBp SMinBp QMinGaps QMaxGaps QMinGapBp QMaxGapBp SMinGaps SMaxGaps SMinGapBp SMaxGapBp AMinGaps AMaxGaps AMinGapBp AMaxGapBp /;
my @vals = ($MinIdtBp, $QMinBp, $SMinBp, $QMinGaps, $QMaxGaps, $QMinGapBp, $QMaxGapBp, $SMinGaps, $SMaxGaps, $SMinGapBp, $SMaxGapBp, $AMinGaps, $AMaxGaps, $AMinGapBp, $AMaxGapBp);
foreach my $i (0..$#vars) {
    next unless defined $vals[$i];
    unless ($vals[$i] > 0) {
	$valfail = 1;
	print "$0: Parameter '$vars[$i]' value '$vals[$i]' is not a positive integer!\n";
    }
}
die "$0: Some parameters were outside acceptable ranges!  Stopping.\n" if $valfail;

$outprefix = $alignfile unless $outprefix;
#print "\$outprefix: $outprefix\n";
$QMaxGaps = $QMaxGapBp = $SMaxGaps = $SMaxGapBp = 0 if $gapless;
die "$0: Cannot specify both 'mostgaps' and 'leastgaps'!\n" if $mostgaps && $leastgaps;

die "Using -QMinSim or -SMinSim requires --more!\n" if (($QMinSim || $SMinSim) && !$more);

my ($header, @qheaders, @sheaders, %blocks, %lengths, %status, %queryNs, $qheaderflag, $sheaderflag);
my ($qrycount, $aligns, $usecount, $outheader, @blatheader, %scored, $bestaln);

if ($queryfa) {

    open my $INQ, '<', $queryfa or die "$0: Can't read query fasta '$queryfa': $!\n";
    while (<$INQ>) {
	if ($_ =~ /^>(.*)/) {
#	    $header = $1;
	    $header = (split /\s+/, $1)[0];  # this is how blast sees it
	    push @qheaders, $header;
	    $status{Q}{$header} = 0;
	} else {
	    $blocks{Q}{$header} .= $_;
	    $lengths{Q}{$header} += length($_)-1;  # -1 due to retained newline
	}    
    }
    close $INQ;
    $qheaderflag = 1;
    foreach my $query (@qheaders) {
	(my $seq = $blocks{Q}{$query}) =~ s/[\n\r]//g;
	$queryNs{$query}++ while $seq =~ /N/ig;
    }
}

if ($self) {

    $lengths{S} = $lengths{Q};
    @sheaders = @qheaders;

} elsif ($subjfa) {

    open my $INS, '<', $subjfa or die "$0: Can't read subject fasta '$subjfa': $!\n";
    while (<$INS>) {
	$_ =~ s/[\n\r]+$//;
	if ($_ =~ /^>(.*)/) {
#	    $header = $1;
	    $header = (split /\s+/, $1)[0];  # this is how blast sees it
	    push @sheaders, $header;
	    $status{S}{$header} = 0;
	} else {
	    $lengths{S}{$header} += length($_);
	}    
    }
    close $INS;
    $sheaderflag = 1;
}

open my $IN, '<', $alignfile or die "$0: Can't read alignment file '$alignfile': $!\n";
my $OUT;
unless ($best || $pairbest) {
    open $OUT, '>', "$outprefix.filtered" or die "$0: Can't write to '$outprefix.filtered': $!\n";
}










if ($type eq 'blast') {
    


    if ($QMinGaps) {
	print "WARNING: Query min gaps can only be 0/1 if using NCBI-blast: converting to 1\n" if $QMinGaps > 1;
	$QMinGaps = 1;  #### CONVERT TO BINARY -- ALL WE CAN CONSISTENTLY TEST
    }
    if ($SMinGaps) {
	print "WARNING: Subject min gaps can only be 0/1 if using NCBI-blast: converting to 1\n" if $SMinGaps > 1;
	$SMinGaps = 1;  #### CONVERT TO BINARY -- ALL WE CAN CONSISTENTLY TEST
    }
    if ($QMaxGaps) {
	print "WARNING: Query max gaps can only be 0/1 if using NCBI-blast: converting to 1\n" if $QMaxGaps > 1;
	$QMaxGaps = 1;  #### CONVERT TO BINARY -- ALL WE CAN CONSISTENTLY TEST
    }
    if ($SMaxGaps) {
	print "WARNING: Subject max gaps can only be 0/1 if using NCBI-blast: converting to 1\n" if $SMaxGaps > 1;
	$SMaxGaps = 1;  #### CONVERT TO BINARY -- ALL WE CAN CONSISTENTLY TEST
    }
    
    $outheader = "Query\tSubject\tIdtPct\tAlnLen\tMismatch\tGaps\tQStart\tQEnd\tSStart\tSEnd\tEval\tScore";
    $outheader .= "\tStrand\tIdtBp\tQLen\tQLenPct\tAQIdtPct\tTQIdtPct\tQSimPct\tSLen\tSLenPct\tASIdtPct\tTSIdtPct\tSSimPct" if $more;
    print $OUT "$outheader\n" unless $best || $pairbest;
    
    while (<$IN>) {
	(my $line = $_) =~ s/[\n\r]+$//g;
	next unless $line;
	my ($query, $subj, $idt, $mlen, $mms, $Ngaps, $qpos1, $qpos2, $spos1, $spos2, $eval, $score) = split /\t/, $line;
	push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	$status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	next if ($self && $query eq $subj);
	my $strand = ($spos1 > $spos2 || $qpos1 > $qpos2) ? '-' : '+';
	next if ($noanti && $strand eq '-');
	my ($qstart, $qend) = (sort {$a <=> $b} ($qpos1, $qpos2));
	my ($sstart, $send) = (sort {$a <=> $b} ($spos1, $spos2));
	my ($qrange, $srange) = ($qend-$qstart+1, $send-$sstart+1);
	next if ($QMinBp && $qrange < $QMinBp);
	next if ($SMinBp && $srange < $SMinBp);
	my $identbp = sprintf("%0.0f", $idt*$mlen/100);	
        next if ($MinIdtBp && $identbp < $MinIdtBp);
	my $qgapbp = $mlen-$qrange;
	my $sgapbp = $mlen-$srange;
	my $qgaps = $mlen > $qrange ? 1 : 0;  #### UNFORTUNATELY, CANNOT ALWAYS RECOVER NUMBER OF GAPS - CONVERT TO PRESENCE/ABSENCE ONLY
	my $sgaps = $mlen > $srange ? 1 : 0;
	next if (defined $QMaxGaps && $QMaxGaps == 0 && $qgaps);  # inline filter for gapless alignments is ok
	next if (defined $SMaxGaps && $SMaxGaps == 0 && $sgaps);  # inline filter for gapless alignments is ok
	unless ($gaptestlast) {
	    next if ($QMinGaps && $qgaps < $QMinGaps);
	    next if ($QMinGapBp && $qgapbp < $QMinGapBp);
	    next if ($SMinGaps && $sgaps < $SMinGaps);
	    next if ($SMinGapBp && $sgapbp < $SMinGapBp);
	    next if ($AMinGaps && $Ngaps < $AMinGaps);
	    next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
	    next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
	    next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
	    next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
	    next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
	    next if (defined $AMaxGaps && $Ngaps > $AMaxGaps);
	    next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
	}
	my ($querylen) = $qlen ? ($query =~ /(\d+)$/) : $lengths{Q}{$query};
	my ($subjlen) = $slen ? ($subj =~ /(\d+)$/) : $lengths{S}{$subj};
	my ($aqidtpct, $tqidtpct, $asidtpct, $tsidtpct, $qlenpct, $slenpct, $qsimpct, $ssimpct);
	if ($querylen) {
	    $aqidtpct = $qrange ? $identbp/$qrange : 0;
	    $tqidtpct = $identbp/$querylen;
	    $qlenpct = $qrange/$querylen;
	    $qsimpct = $tqidtpct*$qlenpct;
	    ## test first
	    next if ($AQMinIdt && $aqidtpct < $AQMinIdt);
	    next if ($TQMinIdt && $tqidtpct < $TQMinIdt);
	    next if ($QMinLen && $qlenpct < $QMinLen);
	    next if ($QMinSim && $qsimpct < $QMinSim);
	}
	if ($subjlen) {
	    $asidtpct = $srange ? $identbp/$srange : 0;
	    $tsidtpct = $identbp/$subjlen;
	    $slenpct = $srange/$subjlen;
	    $ssimpct = $tsidtpct*$slenpct;
	    ## test first
	    next if ($ASMinIdt && $asidtpct < $ASMinIdt);
	    next if ($TSMinIdt && $tsidtpct < $TSMinIdt);
	    next if ($SMinLen && $slenpct < $SMinLen);
	    next if ($SMinSim && $ssimpct < $SMinSim);
	}
	if ($more) {
	    if ($querylen) {
		## tidy for printing
		$aqidtpct = sprintf("%0.2f", 100*$aqidtpct);
		$tqidtpct = sprintf("%0.2f", 100*$tqidtpct);
		$qlenpct = sprintf("%0.2f", 100*$qlenpct);
		$qsimpct = sprintf("%0.2f", 100*$qsimpct);
	    } else {
		$aqidtpct = $tqidtpct = $qlenpct = $qsimpct = 'NA';
	    }	    
	    if ($subjlen) {
		$asidtpct = sprintf("%0.2f", 100*$asidtpct);
		$tsidtpct = sprintf("%0.2f", 100*$tsidtpct);
		$slenpct = sprintf("%0.2f", 100*$slenpct);
		$ssimpct = sprintf("%0.2f", 100*$ssimpct);
	    } else {
		$asidtpct = $tsidtpct = $slenpct = $ssimpct = 'NA';
	    }	    
	    $line .= join "\t", ('', $strand, $identbp, $querylen, $qlenpct, $aqidtpct, $tqidtpct, $qsimpct, $subjlen, $slenpct, $asidtpct, $tsidtpct, $ssimpct);   # lead '' results in leading \t
	}
	$status{Q}{$query} = 2;
	$status{S}{$subj} = 2;
	if ($best) {
	    $scored{$query}{$score}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp, $subj];
	} elsif ($pairbest) {
	    $scored{$query}{$subj}{$score}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp];
	} else {
	    print $OUT "$line\n";
	    $bestaln++;
	}
    }
    $aligns = $.;










} elsif ($type eq 'wublast') {



    $outheader = "Query\tSubject\tE-Val\tNscores\tNormScore\tRawScore\tAlnLen\tIdentBp\tPositive\tMismatch\tIdtPct\tPosPct\tQGaps\tQGapBp\tSGaps\tSGapBp\tQFrame\tQStart\tQEnd\tSFrame\tSStart\tSEnd";
    $outheader .= "\tStrand\tQLen\tQLenPct\tAQIdtPct\tTQIdtPct\tQSimPct\tSLen\tSLenPct\tASIdtPct\tTSIdtPct\tSSimPct" if $more;
    print $OUT "$outheader\n" unless $best || $pairbest;
    
    while (<$IN>) {
	(my $line = $_) =~ s/[\n\r]+$//g;
	next unless $line;
	my ($query, $subj, $eval, $nscores, $normscore, $rawscore, $mlen, $identbp, $npos, $mms, $idtpct, $pospct, $qgaps, $qgapbp, $sgaps, $sgapbp, $qframe, $qpos1, $qpos2, $sframe, $spos1, $spos2) = split /\t/, $line;
	push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	$status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	next if ($self && $query eq $subj);
        next if ($MinIdtBp && $identbp < $MinIdtBp);
	next if (defined $QMaxGaps && $QMaxGaps == 0 && $qgaps);  # inline filter for gapless alignments is ok
	next if (defined $SMaxGaps && $SMaxGaps == 0 && $sgaps);  # inline filter for gapless alignments is ok
	unless ($gaptestlast) {
	    next if ($QMinGaps && $qgaps < $QMinGaps);
	    next if ($QMinGapBp && $qgapbp < $QMinGapBp);
	    next if ($SMinGaps && $sgaps < $SMinGaps);
	    next if ($SMinGapBp && $sgapbp < $SMinGapBp);
	    next if ($AMinGaps && $qgaps+$sgaps < $AMinGaps);
	    next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
	    next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
	    next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
	    next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
	    next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
	    next if (defined $AMaxGaps && $qgaps+$sgaps > $AMaxGaps);
	    next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
	}
	my ($qrange, $srange) = (abs($qpos2-$qpos1)+1, abs($spos2-$spos1)+1);
	next if ($QMinBp && $qrange < $QMinBp);
	next if ($SMinBp && $srange < $SMinBp);
	my $strand = $qpos1 < $qpos2 ? '+' : '-';
	next if ($noanti && $strand eq '-');
	my ($querylen) = $qlen ? ($query =~ /(\d+)$/) : $lengths{Q}{$query};
	my ($subjlen) = $slen ? ($subj =~ /(\d+)$/) : $lengths{S}{$subj};
	my ($aqidtpct, $tqidtpct, $asidtpct, $tsidtpct, $qlenpct, $slenpct, $qsimpct, $ssimpct);
	if ($querylen) {
	    $aqidtpct = $qrange ? $identbp/$qrange : 0;
	    $tqidtpct = $identbp/$querylen;
	    $qlenpct = $qrange/$querylen;
	    $qsimpct = $tqidtpct*$qlenpct;
	    ## test first
	    next if ($AQMinIdt && $aqidtpct < $AQMinIdt);
	    next if ($TQMinIdt && $tqidtpct < $TQMinIdt);
	    next if ($QMinLen && $qlenpct < $QMinLen);
	    next if ($QMinSim && $qsimpct < $QMinSim);
	}
	if ($subjlen) {
	    $asidtpct = $srange ? $identbp/$srange : 0;
	    $tsidtpct = $identbp/$subjlen;
	    $slenpct = $srange/$subjlen;
	    $ssimpct = $tsidtpct*$slenpct;
	    ## test first
	    next if ($ASMinIdt && $asidtpct < $ASMinIdt);
	    next if ($TSMinIdt && $tsidtpct < $TSMinIdt);
	    next if ($SMinLen && $slenpct < $SMinLen);
	    next if ($SMinSim && $ssimpct < $SMinSim);
	}
	if ($more) {
	    if ($querylen) {
		## tidy for printing
		$aqidtpct = sprintf("%0.2f", 100*$aqidtpct);
		$tqidtpct = sprintf("%0.2f", 100*$tqidtpct);
		$qlenpct = sprintf("%0.2f", 100*$qlenpct);
		$qsimpct = sprintf("%0.2f", 100*$qsimpct);
	    } else {
		$aqidtpct = $tqidtpct = $qlenpct = $qsimpct = 'NA';
	    }	    
	    if ($subjlen) {
		$asidtpct = sprintf("%0.2f", 100*$asidtpct);
		$tsidtpct = sprintf("%0.2f", 100*$tsidtpct);
		$slenpct = sprintf("%0.2f", 100*$slenpct);
		$ssimpct = sprintf("%0.2f", 100*$ssimpct);
	    } else {
		$asidtpct = $tsidtpct = $slenpct = $ssimpct = 'NA';
	    }	    
	    $line .= join "\t", ('', $strand, $querylen, $qlenpct, $aqidtpct, $tqidtpct, $qsimpct, $subjlen, $slenpct, $asidtpct, $tsidtpct, $ssimpct);   # lead '' results in leading \t
	}
	$status{Q}{$query} = 2;
	$status{S}{$subj} = 2;
	if ($best) {
	    $scored{$query}{$rawscore}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp, $subj];
	} elsif ($pairbest) {
	    $scored{$query}{$subj}{$rawscore}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp];
	} else {
	    print $OUT "$line\n";
	    $bestaln++;
	}
    }
    $aligns = $.;










} elsif ($type eq 'blat') {
    



    while (<$IN>) {
	(my $line = $_) =~ s/[\n\r]+$//g;
	if ($. < 6) {  # HEADERS
	    push @blatheader, $line;
	    next;
	} elsif ($. == 6) {  # FIRST ALIGNMENT LINE -- ORGANIZE HEADERS BEFORE CONTINUING
	    if ($more) {
		my $extra = "\tQLenPct\tAQIdtPct\tTQIdtPct\tQSimPct\tSLenPct\tASIdtPct\tTSIdtPct\tSSimPct";
		$blatheader[2] .= $extra;
		$blatheader[4] .= '-' x length($extra);  # will be short due to tab expansions, but whatever
	    }
	    $outheader = join "\n", @blatheader;
	    print $OUT "$outheader\n" unless $best || $pairbest;
	}
	next unless $line;
	my ($ident, $mismatch, $reps, $Ns, $qgaps, $qgapbp, $sgaps, $sgapbp, $strand, $query, $querylen, $qpos1, $qpos2, $subj, $subjlen, $spos1, $spos2, $blocks, $blocksizes, $qstarts, $tstarts) = split /\t/, $line;
	push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	$status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	next if ($self && $query eq $subj);
	next if ($noanti && $strand eq '-');
	next if (defined $QMaxGaps && $qgaps > $QMaxGaps);	# 'defined' because $maxgaps could be 0
	next if (defined $SMaxGaps && $sgaps > $SMaxGaps);	# 'defined' because $maxgaps could be 0
	unless ($gaptestlast) {
	    next if ($QMinGaps && $qgaps < $QMinGaps);
	    next if ($QMinGapBp && $qgapbp < $QMinGapBp);
	    next if ($SMinGaps && $sgaps < $SMinGaps);
	    next if ($SMinGapBp && $sgapbp < $SMinGapBp);
	    next if ($AMinGaps && $qgaps+$sgaps < $AMinGaps);
	    next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
	    next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
	    next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
	    next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
	    next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
	    next if (defined $AMaxGaps && $qgaps+$sgaps > $AMaxGaps);
	    next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
	}
	my ($qrange, $srange) = (abs($qpos2-$qpos1), abs($spos2-$spos1));   # blat uses 0-based coords
	my $identbp = $ident + $reps;
	next if ($QMinBp && $qrange < $QMinBp);
	next if ($SMinBp && $srange < $SMinBp);
        next if ($MinIdtBp && $identbp < $MinIdtBp);
	my ($aqidtpct, $tqidtpct, $asidtpct, $tsidtpct, $qlenpct, $slenpct, $qsimpct, $ssimpct);
#	print STDERR "$alignfile $.: $query = $querylen\n" unless $querylen;
#	print STDERR "$alignfile $.: $subj = $subjlen\n" unless $subjlen;
	if ($querylen) {
	    $aqidtpct = $qrange ? $identbp/$qrange : 0;
	    $tqidtpct = $identbp/$querylen;
	    $qlenpct = $qrange/$querylen;
	    $qsimpct = $tqidtpct*$qlenpct;
	    ## test first
	    next if ($AQMinIdt && $aqidtpct < $AQMinIdt);
	    next if ($TQMinIdt && $tqidtpct < $TQMinIdt);
	    next if ($QMinLen && $qlenpct < $QMinLen);
	    next if ($QMinSim && $qsimpct < $QMinSim);
	}
	if ($subjlen) {
	    $asidtpct = $srange ? $identbp/$srange : 0;
	    $tsidtpct = $identbp/$subjlen;
	    $slenpct = $srange/$subjlen;
	    $ssimpct = $tsidtpct*$slenpct;
	    ## test first
	    next if ($ASMinIdt && $asidtpct < $ASMinIdt);
	    next if ($TSMinIdt && $tsidtpct < $TSMinIdt);
	    next if ($SMinLen && $slenpct < $SMinLen);
	    next if ($SMinSim && $ssimpct < $SMinSim);
	}
	if ($more) {	    ## tidy for printing
	    $aqidtpct = sprintf("%0.2f", 100*$aqidtpct);
	    $tqidtpct = sprintf("%0.2f", 100*$tqidtpct);
	    $qlenpct = sprintf("%0.2f", 100*$qlenpct);
	    $qsimpct = sprintf("%0.2f", 100*$qsimpct);
	    $asidtpct = sprintf("%0.2f", 100*$asidtpct);
	    $tsidtpct = sprintf("%0.2f", 100*$tsidtpct);
	    $slenpct = sprintf("%0.2f", 100*$slenpct);
	    $ssimpct = sprintf("%0.2f", 100*$ssimpct);
	    $line .= join "\t", ('', $qlenpct, $aqidtpct, $tqidtpct, $qsimpct, $slenpct, $asidtpct, $tsidtpct, $ssimpct);   # lead '' results in leading \t
	}
	$status{Q}{$query} = 2;
	$status{S}{$subj} = 2;
	if ($best) {
	    $scored{$query}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp, $subj];
	} elsif ($pairbest) {
	    $scored{$query}{$subj}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp];
	} else {
	    print $OUT "$line\n";
	    $bestaln++;
	}
    }
    $aligns = $.-5;
    









} elsif ($type eq 'exonerate') {
    



    my $Sfilters = ($ASMinIdt || $TSMinIdt || $SMinLen || $SMinBp || $SMinGaps || $SMinGapBp || defined $SMaxGaps || defined $SMaxGapBp) ? 1 : 0;
    print "Subject-similarity filters are ignored for Exonerate '-m est2genome' parsing, since the subject is the genome...\n" if $Sfilters;
    
    $outheader = "Query\tSubject\tIdent\tMismatch\tQGaps\tQGapBp\tSGaps\tSGapBp\tQLen\tSLen\tQStart\tQEnd\tSStart\tSEnd\tStrand\tScore\tQLenPct\tAQIdtPct\tTQIdtPct\tQSimPct\tSLenPct\tASIdtPct\tTSIdtPct\tSSimPct\tBlocks\tBlockSizes\tQueryStarts\tSubjStarts";
    print $OUT "$outheader\n";
    
   my ($gap, $query, $offset, $linelen, %alndat);
    while (<$IN>) {
	$_ =~ s/[\n\r]+$//g;
	if ($_ =~ /\s+Query: (.*)/) {   # begin new alignment
	    $query = $1;
	    $aligns++;
	    $gap = 0;
	    %alndat = ();
	    push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	    $status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	} elsif ($_ !~ /\S/) {   # blank line
	    $gap = 1;
	} elsif ($_ =~ /^(\s*\d+ : )(.*) : \d+/) {   # alignment blocks
	    if ($gap) {   # starting new triplet
		$offset = length($1);   # length(largest_position)+4
		$linelen = length($2);  # usually 56 ?
		$alndat{1} .= $2;
	    } else {      # terminating triplet
		$alndat{3} .= $2;
	    }
	    $gap = 0;
	} elsif ($_ =~ /^\s+\|/) {   # alignment block middle line
	    $alndat{2} .= substr($_, $offset-1, $linelen);
	    $gap = 0;
	} elsif ($_ =~ /^cigar: (.*)/) {   # cigar line
	    my ($query1, $qpos1, $qpos2, $qstr, $subj, $spos1, $spos2, $strand, $score, $cigar) = split /\s+/, $1, 10;
	    push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	    $status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	    print "$.: $query != $query1!\n" unless $query eq $query1;  # hopefully all lines are in order?
	    $gap = 0;
	    my ($qstart, $qend) = ($qpos1 < $qpos2) ? ($qpos1, $qpos2) : ($qpos2, $qpos1);
	    my ($sstart, $send) = ($spos1 < $spos2) ? ($spos1, $spos2) : ($spos2, $spos1);
	    my $qrange = $qend-$qstart;   # exonerate uses 0-based coords
	    my $srange = $send-$sstart;   # exonerate uses 0-based coords
	    next if ($QMinBp && $qrange < $QMinBp);
	    next if ($SMinBp && $srange < $SMinBp);
	    my ($querylen) = $qlen ? ($query =~ /(\d+)$/) : $lengths{Q}{$query};
	    my ($subjlen) = $slen ? ($subj =~ /(\d+)$/) : $lengths{S}{$subj};
	    my ($identbp, $introns, $intronbp, $sgapbp, $qgapbp);
	    $identbp++ while $alndat{2} =~ /\|/g;
	    next if ($MinIdtBp && $identbp < $MinIdtBp);
	    my ($aqidtpct, $tqidtpct, $asidtpct, $tsidtpct, $qlenpct, $slenpct, $qsimpct, $ssimpct);
	    if ($querylen) {
		$aqidtpct = $qrange ? $identbp/$qrange : 0;
		$tqidtpct = $identbp/$querylen;
		$qlenpct = $qrange/$querylen;
		$qsimpct = $tqidtpct*$qlenpct;
		## test first
		next if ($AQMinIdt && $aqidtpct < $AQMinIdt);
		next if ($TQMinIdt && $tqidtpct < $TQMinIdt);
		next if ($QMinLen && $qlenpct < $QMinLen);
		next if ($QMinSim && $qsimpct < $QMinSim);
	    }
	    if ($subjlen) {
		$asidtpct = $srange ? $identbp/$srange : 0;
		$tsidtpct = $identbp/$subjlen;
		$slenpct = $srange/$subjlen;
		$ssimpct = $tsidtpct*$slenpct;
		## test first
		next if ($ASMinIdt && $asidtpct < $ASMinIdt);
		next if ($TSMinIdt && $tsidtpct < $TSMinIdt);
		next if ($SMinLen && $slenpct < $SMinLen);
		next if ($SMinSim && $ssimpct < $SMinSim);
	    }
	    $aqidtpct = sprintf("%0.2f", 100*$aqidtpct);
	    $tqidtpct = sprintf("%0.2f", 100*$tqidtpct);
	    $qlenpct = sprintf("%0.2f", 100*$qlenpct);
	    $qsimpct = sprintf("%0.2f", 100*$qsimpct);
	    $asidtpct = sprintf("%0.2f", 100*$asidtpct);
	    $tsidtpct = sprintf("%0.2f", 100*$tsidtpct);
	    $slenpct = sprintf("%0.2f", 100*$slenpct);
	    $ssimpct = sprintf("%0.2f", 100*$ssimpct);
	    $introns++ while $alndat{1} =~ /Intron/g;
	    $intronbp += $& while $alndat{2} =~ /\d+/g;
	    my @qgaps = split /[\w.]+/, $alndat{3};     ## GAPS WRT QUERY, = GAPS IN SUBJECT ??????  Trying to copy blat...
	    my @sgaps = split /[\w.\s>]+/, $alndat{1};  ## GAPS WRT SUBJECT, = GAPS IN QUERY ??????  Trying to copy blat...
	    my $qgaps = scalar @qgaps;
	    my $sgaps = scalar @sgaps;
	    next if (defined $QMaxGaps && $qgaps > $QMaxGaps);	# 'defined' because $maxgaps could be 0
	    next if (defined $SMaxGaps && $sgaps > $SMaxGaps);	# 'defined' because $maxgaps could be 0
	    unless ($gaptestlast) {
		next if ($QMinGaps && $qgaps < $QMinGaps);
		next if ($QMinGapBp && $qgapbp < $QMinGapBp);
		next if ($SMinGaps && $sgaps < $SMinGaps);
		next if ($SMinGapBp && $sgapbp < $SMinGapBp);
		next if ($AMinGaps && $qgaps+$sgaps < $AMinGaps);
		next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
		next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
		next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
		next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
		next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
		next if (defined $AMaxGaps && $qgaps+$sgaps > $AMaxGaps);
		next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
	    }
	    $qgapbp += length($_) foreach @qgaps;
	    $sgapbp += length($_) foreach @sgaps;
	    my $mismatch = $qrange-$identbp-$qgapbp;
	    my $blocks = $introns+1;
	    (my $gapless = $alndat{1}) =~ s/-//g;
	    my @blocks = split /  >>>> Target Intron \d+ >>>>  /, $gapless;
	    my @blocksizes = map { length($_) } @blocks;
	    my @qstarts = ($qstart);
	    my @sstarts = ($sstart);
	    foreach my $i (0..$#blocksizes) {
		push @qstarts, $qstarts[$i]+$blocksizes[$i];
		push @sstarts, $sstarts[$i]+$blocksizes[$i];
	    }
	    my $qblockend = shift @qstarts;
	    my $sblockend = shift @sstarts;
	    print "$.: Query block end $qblockend != query align end $qend!\n" if $qblockend != $qend;
	    print "$.: Subject block end $sblockend != subject align end $send!\n" if $sblockend != $send;
	    my $blocksizes = join ',', @blocksizes;
	    my $qstarts = join ',', @qstarts;
	    my $sstarts = join ',', @sstarts;
	    my $line = join "\t", ($query, $subj, $identbp, $mismatch, $qgaps, $qgapbp, $sgaps, $sgapbp, $querylen, $subjlen, $qstart, $qend, $sstart, $send, $strand, $score, $qlenpct, $aqidtpct, $tqidtpct, $qsimpct, $slenpct, $asidtpct, $tsidtpct, $ssimpct, $blocks, $blocksizes, $qstarts, $sstarts);
	    $status{Q}{$query} = 2;
	    $status{S}{$subj} = 2;
	    if ($best) {
		$scored{$query}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp, $subj];
	    } elsif ($pairbest) {
		$scored{$query}{$subj}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp];
	    } else {
		print $OUT "$line\n";
		$bestaln++;
	    }
	}
    }
    









} elsif ($type eq 'sam') {
    



    $outheader = "Header\tFlags\tChrom\tSStart\tMateStart\tCigar1\tMateChr\t.\t.\tSequence\tQuality\t.\t.\t.\t.\t.\t.\t.\tCigar2\t.";
    $outheader .= "\tStrand\tIdtBp\tMismatch\tNs\tQLen\tQStart\tQEnd\tQGaps\tQGapBp\tQLenPct\tAQIdtPct\tTQIdtPct\tQSimPct\tSLen\tSEnd\tSGaps\tSGapBp\tSLenPct\tASIdtPct\tTSIdtPct\tSSimPct" if $more;
    print $OUT "$outheader\n";
    
    my @samheaders;
    while (<$IN>) {
	(my $line = $_) =~ s/[\n\r]+$//;
	next unless $line;
	if ($_ =~ /^@/) {
	    push @samheaders, "$_\n";   # currently, nothing is done with these SAM header lines....
	    next;
	}
	my @data = split /\t/, $_;
	my ($query, $flags, $subj, $sstart, $mstart, $cigar1, $msubj, $X, $Y, $seq, $cigar2) = @data[0..9,18];
	push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	$status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	next if ($self && $query eq $subj);
	next if $subj eq '*';
	my $strand = $flags & 16 ? '-' : '+';
	next if ($noanti && $strand eq '-');
	my $querylen = length($seq);
	my ($subjlen) = $slen ? ($subj =~ /(\d+)$/) : $lengths{S}{$subj};
	my ($alnbp, $skipped, $qstart, $qend, $Ns, $qgaps, $sgaps, $qgapbp, $sgapbp) = (0, 0, 0, 0, 0, 0, 0, 0, 0);
	$cigar2 =~ s/^MD:Z://;     # strip field header
	$cigar2 =~ s/\^[A-Z]+//g;  # strip all deletion markers
	my $mismatches = scalar (split /\d+/, $cigar2);
	$Ns++ while $seq =~ /N/ig;
	my @fields = split /(?<=[A-Z])/, $cigar1;
	pop @fields unless $fields[-1];  # drop last element if null; artifact of splitting on look-behinds
	foreach my $i (0..$#fields) {
	    my ($bp, $class) = ($fields[$i] =~ /^(\d+)([A-Z])$/);
	    if ($class eq 'M') {   # match
		$alnbp += $bp;
	    } elsif ($class eq 'I') {  # insertion (INSERTION IN QUERY / DELETION IN SUBJECT)
		$sgaps++;
		$sgapbp += $bp;
	    } elsif ($class eq 'D') {  # deletion (DELETION IN QUERY / INSERTION IN SUBJECT)
		$qgaps++;
		$qgapbp += $bp;
	    } elsif ($class eq 'N') {  # Non-aligned gap (e.g. splice junction)
		$qgaps++;
		$qgapbp += $bp;
	    } elsif ($class eq 'S') {  # skipped bases (not involved in alignment -- should occur ONLY on query flanks)
		$skipped += $bp;
		if ($i == 0) {  # leading skip
		    $qstart = $bp+1;
		} elsif ($i == $#fields) {  # trailing skip
		    $qend = $querylen - $bp;
		} else {
		    print "Internal skip event!  $cigar1\n";
		}
	    } elsif ($class) {
		print "Don't know what to do with cigar class '$class'!  Alignment stats may be inaccurate.\n";
	    }
	}
	next if (defined $QMaxGaps && $QMaxGaps == 0 && $qgaps);  # inline filter for gapless alignments is ok
	next if (defined $SMaxGaps && $SMaxGaps == 0 && $sgaps);  # inline filter for gapless alignments is ok
	unless ($gaptestlast) {
	    next if ($QMinGaps && $qgaps < $QMinGaps);
	    next if ($QMinGapBp && $qgapbp < $QMinGapBp);
	    next if ($SMinGaps && $sgaps < $SMinGaps);
	    next if ($SMinGapBp && $sgapbp < $SMinGapBp);
	    next if ($AMinGaps && $qgaps+$sgaps < $AMinGaps);
	    next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
	    next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
	    next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
	    next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
	    next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
	    next if (defined $AMaxGaps && $qgaps+$sgaps > $AMaxGaps);
	    next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
	}
	my ($qrange, $srange, $identbp) = ($alnbp+$sgapbp, $alnbp+$qgapbp, $alnbp-$mismatches);
        next if ($MinIdtBp && $identbp < $MinIdtBp);
	next if ($QMinBp && $qrange < $QMinBp);
	next if ($SMinBp && $srange < $SMinBp);
	$qstart = 1 unless $qstart;
	$qend = $querylen unless $qend;
	my $qrange2 = $qend-$qstart+1;
	print "Query range ${qrange}bp does not match positions $qstart-$qend (${qrange2}bp) | $querylen, $cigar1!\n" unless $qrange == $qrange2;
	my $send = $sstart ? $sstart+$srange-1 : 0;
	my ($aqidtpct, $tqidtpct, $asidtpct, $tsidtpct, $qlenpct, $slenpct, $qsimpct, $ssimpct);
	if ($querylen) {
	    $aqidtpct = $qrange ? $identbp/$qrange : 0;
	    $tqidtpct = $identbp/$querylen;
	    $qlenpct = $qrange/$querylen;
	    $qsimpct = $tqidtpct*$qlenpct;
	    ## test first
	    next if ($AQMinIdt && $aqidtpct < $AQMinIdt);
	    next if ($TQMinIdt && $tqidtpct < $TQMinIdt);
	    next if ($QMinLen && $qlenpct < $QMinLen);
	    next if ($QMinSim && $qsimpct < $QMinSim);
	}
	if ($subjlen) {
	    $asidtpct = $srange ? $identbp/$srange : 0;
	    $tsidtpct = $identbp/$subjlen;
	    $slenpct = $srange/$subjlen;
	    $ssimpct = $tsidtpct*$slenpct;
	    ## test first
	    next if ($ASMinIdt && $asidtpct < $ASMinIdt);
	    next if ($TSMinIdt && $tsidtpct < $TSMinIdt);
	    next if ($SMinLen && $slenpct < $SMinLen);
	    next if ($SMinSim && $ssimpct < $SMinSim);
	}
	if ($more) {
	    if ($querylen) {
		## tidy for printing
		$aqidtpct = sprintf("%0.2f", 100*$aqidtpct);
		$tqidtpct = sprintf("%0.2f", 100*$tqidtpct);
		$qlenpct = sprintf("%0.2f", 100*$qlenpct);
		$qsimpct = sprintf("%0.2f", 100*$qsimpct);
	    } else {
		$aqidtpct = $tqidtpct = $qlenpct = $qsimpct = 'NA';
	    }	    
	    if ($subjlen) {
		$asidtpct = sprintf("%0.2f", 100*$asidtpct);
		$tsidtpct = sprintf("%0.2f", 100*$tsidtpct);
		$slenpct = sprintf("%0.2f", 100*$slenpct);
		$ssimpct = sprintf("%0.2f", 100*$ssimpct);
	    } else {
		$asidtpct = $tsidtpct = $slenpct = $ssimpct = 'NA';
	    }	    
	    $line .= join "\t", ('', $strand, $identbp, $mismatches, $Ns, $querylen, $qstart, $qend, $qgaps, $qgapbp, $qlenpct, $aqidtpct, $tqidtpct, $qsimpct, $subjlen, $send, $sgaps, $sgapbp, $slenpct, $asidtpct, $tsidtpct, $ssimpct);   # lead '' results in leading \t
	}
	$status{Q}{$query} = 2;
	$status{S}{$subj} = 2;
	if ($best) {
	    $scored{$query}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp, $subj];
	} elsif ($pairbest) {
	    $scored{$query}{$subj}{$identbp}{$line} = [$qgaps, $qgapbp, $sgaps, $sgapbp];
	} else {
	    print $OUT "$line\n";
	    $bestaln++;
	}
    }
    $aligns = $.;
    









} elsif ($type eq 'transfac') {
    



    my $query;
    while (<$IN>) {
	my $qline;
	if ($_ =~ /^Inspecting sequence ID\s+(.*)/) {
	    $query = $1;
	    push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
	    $status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
	    $qline = 1;
	}
	my @data = (split /[\s\|]+/, $_)[1..6];  # drop blank first element
	my ($subj, $cscore, $mscore) = @data[0,3,4];
	push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};  # maintain input order
	$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
	next if ($cscore > 1 || $mscore > 1);   # junk alignments
	$status{Q}{$query} = 2;
	$status{S}{$subj} = 2;
	if ($tabular) {
	    $data[2] =~ s/[\(\)]//g;
	    print $OUT (join "\t", ($query, @data)), "\n" unless ($. < 4 || $qline || $_ !~ /\S/);   # skip query deflines and blank lines
	} else {
	    print $OUT $_;
	}
	$bestaln++;
    }
    









} elsif ($type eq 'miranda') {
    



    $outheader = "Subject\tQuery\tScore\tEnergy\tUnknown1\tUnknown2\tQStart\tQEnd\tSStart\tSEnd\tAlnLen\tIdtPct\tSimPct";
    
    if ($best || $pairbest) {
	
	my $capture;
	while (<$IN>) {
	    $_ =~ s/[\n\r]+$//;
	    if ($capture && $_ =~ /^>([^>].*)/) {  # MATCH '>' NOT '>>'
		(my $line = $1) =~ s/\s+/\t/g;
		my ($subj, $query, $score, $energy, $blah1, $blah2, $qstart, $qend, $sstart, $send, $mlen, $idtpct, $simpct) = split /\t/, $line;
		$aligns++;
		push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
		push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};    # maintain input order
		$status{Q}{$query} = 1 unless $status{Q}{$query} == 2;
		$status{S}{$subj} = 1 unless $status{S}{$subj} == 2;
#		next if ($MinIdtBp && $identbp < $MinIdtBp);   ####### NEED $identbp
		next if ($ASMinIdt && $idtpct < $ASMinIdt);   # $ASMinIdt tests identity %
		next if ($TSMinIdt && $simpct < $TSMinIdt);   # $TSMinIdt tests alignable % (not only identities)
		my $slenpct = $mlen/$lengths{S}{$subj};
		next if ($SMinLen && $slenpct < $SMinLen);
		$status{Q}{$query} = 2;
		$status{S}{$subj} = 2;
		if ($best) {
		    $scored{$query}{$score}{$line} = [0, 0, 0, 0, $subj];   # gap stats = 0 since, for the most part, gaps are guaranteed, and also meaningless.
		} elsif ($pairbest) {
		    $scored{$query}{$subj}{$score}{$line} = [0, 0, 0, 0];
		}
		$capture = 0;
	    } else {
		$capture = $_ eq 'Scores for this hit:' ? 1 : 0;  # activate capture for next line?
	    }
	}
	
    } else {
	
	print $OUT "$outheader\n" if $tabular;
	
	my (@block, @flatlines, $ok, $query, $subj);
	while (<$IN>) {
	    push @block, $_;
	    $_ =~ s/[\n\r]+$//;
	    if ($_ =~ /^Read Sequence:/) {
		$ok = 0;
		@block = ($block[-1]);  # start with last line pushed, which was this line
		@flatlines = ();
	    } elsif ($_ =~ /^>([^>].*)/) {  # > NOT >>
		(my $line = $1) =~ s/\s+/\t/g;
		$aligns++;
		my ($subj, $query, $score, $energy, $blah1, $blah2, $qstart, $qend, $sstart, $send, $mlen, $idtpct, $simpct) = split /\t/, $line;
		push @qheaders, $query unless $qheaderflag || $status{Q}{$query};  # maintain input order
		push @sheaders, $subj unless $sheaderflag || $status{S}{$subj};    # maintain input order
		$status{Q}{$query} = 1;
		$status{S}{$subj} = 1;
#		next if ($MinIdtBp && $identbp < $MinIdtBp);   ####### NEED $identbp
		next if ($ASMinIdt && $idtpct < $ASMinIdt);   # $ASMinIdt tests identity %
		next if ($TSMinIdt && $simpct < $TSMinIdt);   # $TSMinIdt tests alignable % (not only identities)
		my $slenpct = $mlen/$lengths{S}{$subj};
		next if ($SMinLen && $slenpct < $SMinLen);
		$status{Q}{$query} = 2;
		$status{S}{$subj} = 2;
		$bestaln++;
		push @flatlines, $line if $tabular;
		$ok = 1;
	    } elsif ($_ eq 'Complete') {
		next unless $ok;
		if ($tabular) {
		    print $OUT "$_\n" foreach @flatlines;
		} else {
		    print $OUT @block, "\n";  # extra newline for break, which would be on the next line
		}
	    }
	}
	
    }

}

close IN;



############# FILTERING FOR BEST HITS #############



my (%bestS, $prebest, %prebest, %postbest);
my ($OUT, $LOST);

if ($lost) {
    open $LOST, '>', "$outprefix.lost" or die "Can't write lost queries to '$outprefix.lost': $!\n";
}

if ($best) {
    
    open $OUT, '>', "$outprefix.best" or die "$0: Can't write best alignments to '$outprefix.best': $!\n";
    print $OUT "$outheader\n";

    foreach my $query (@qheaders) {
	
	if ($scored{$query}) {
	    &process_hash(\%{ $scored{$query} });
	} elsif ($lost) {
	    print $LOST ">$query\n$blocks{Q}{$query}";
	}
    }
    close $OUT;
    close $LOST if $lost;

    my $scoredQ = scalar keys %scored;
    my $prebestQ = scalar keys %prebest;
    my $postbestQ = scalar keys %postbest;
#    print "\n$scoredQ scored -> $prebestQ -> $postbestQ";
    
} elsif ($pairbest) {
    
    open $OUT, '>', "$outprefix.pairbest" or die "$0: Can't write pair-best alignments to '$outprefix.pairbest': $!\n";
    print $OUT "$outheader\n";
    
    foreach my $query (@qheaders) {
	
	if ($scored{$query}) {
	    foreach my $subject (sort keys %{ $scored{$query} }) {
		&process_hash(\%{ $scored{$query}{$subject} });
	    }
	} elsif ($lost) {
	    print $LOST ">$query\n$blocks{Q}{$query}";
	}
    }
    close $OUT;
    close $LOST if $lost;

    my $scoredQ = scalar keys %scored;
    my $prebestQ = scalar keys %prebest;
    my $postbestQ = scalar keys %postbest;
#    print "\n$scoredQ scored -> $prebestQ -> $postbestQ";
    
} elsif ($lost) {

    foreach my $query (@qheaders) {
	print $LOST ">$query\n$blocks{Q}{$query}" unless $status{Q}{$query};
    }
    close $LOST;
}

#print "$_: $status{Q}{$_}\n" foreach @qheaders;

my %N;
$N{Q}{0} = $N{S}{0} = 0;  # ensure printable
$N{Q}{ $status{Q}{$_} }++ foreach @qheaders;
$N{S}{ $status{S}{$_} }++ foreach @sheaders;
$N{$_}{A} = $N{$_}{1} + $N{$_}{2} foreach qw/ Q S /;
my $NQ = scalar @qheaders;
my $NS = scalar @sheaders;
my ($NbestS, $blurb) = $best ? (scalar (keys %bestS), 'best') : ($N{S}{2}, 'filtered');
my $subjtype = $type eq 'transfac' ? 'motifs' : 'subjects';
print "\n$NQ queries | $N{Q}{A} aligned | $N{Q}{2} aligned postfilter | $N{Q}{0} unaligned\n";
print "$NS $subjtype | $N{S}{A} aligned | $N{S}{2} aligned postfilter | $N{S}{0} unaligned\n";
print "$aligns total alignments";
my $pbq = scalar keys %prebest;
print " | $prebest pre-best" if $best;
print " | $bestaln $blurb to $N{Q}{2} queries / $NbestS $subjtype\n<Enter> to exit.\n";
exit;






sub process_hash {

    my %x = %{ $_[0] };
    my ($query, $subject) = @_[1,2];
    my @topscores = (sort {$b <=> $a} keys %x)[0..$returnN-1];
    warn "No topscores!!  $query\n" unless @topscores;
    
    foreach my $topscore (@topscores) {
	
	if ($gaptestlast) {     # $gaptestlast means: filter gaps here, not in-line, because if best alignment is still unacceptable, then we can't ignore it until here
	    
	    my %bestgaps;
	    foreach my $line (keys %{ $x{$topscore} }) {
		$prebest++;
		$prebest{$query} = 1;
		my ($qgaps, $qgapbp, $sgaps, $sgapbp, $subj) = @{ $x{$topscore}{$line} };
		next if ($QMinGaps && $qgaps < $QMinGaps);
		next if ($QMinGapBp && $qgapbp < $QMinGapBp);
		next if ($SMinGaps && $sgaps < $SMinGaps);
		next if ($SMinGapBp && $sgapbp < $SMinGapBp);
		next if ($AMinGaps && $qgaps+$sgaps < $AMinGaps);
		next if ($AMinGapBp && $qgapbp+$sgapbp < $AMinGapBp);
		next if (defined $QMaxGaps && $qgaps > $QMaxGaps);
		next if (defined $QMaxGapBp && $qgapbp > $QMaxGapBp);
		next if (defined $SMaxGaps && $sgaps > $SMaxGaps);
		next if (defined $SMaxGapBp && $sgapbp > $SMaxGapBp);
		next if (defined $AMaxGaps && $qgaps+$sgaps > $AMaxGaps);
		next if (defined $AMaxGapBp && $qgapbp+$sgapbp > $AMaxGapBp);
		if ($mostgaps || $leastgaps) {
		    my $agapbp = $qgapbp+$sgapbp;
		    $bestgaps{$agapbp}{$line} = $subj;
		} else {
		    $bestgaps{$line} = $subj;
		}
	    }
	    
	    ## after gap filtering, choose the least/most-gapped alignments among the candidates (or not)
	    
	    if ($leastgaps) {
		my $minGapBp = (sort {$a <=> $b} keys %bestgaps)[0];
		foreach my $line (keys %{ $bestgaps{$minGapBp} }) {
		    print $OUT "$line\n";
		    $bestS{ $bestgaps{$minGapBp}{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    } elsif ($mostgaps) {
		my $maxGapBp = (sort {$b <=> $a} keys %bestgaps)[0];
		foreach my $line (keys %{ $bestgaps{$maxGapBp} }) {
		    print $OUT "$line\n";
		    $bestS{ $bestgaps{$maxGapBp}{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    } else {
		foreach my $line (keys %bestgaps) {
		    print $OUT "$line\n";
		    $bestS{ $bestgaps{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    }
	    
	} else {     #####  NOT using $gaptestlast
	    
	    my %bestgaps;
	    foreach my $line (keys %{ $x{$topscore} }) {
		$prebest++;
		$prebest{$query} = 1;
		my ($qgaps, $qgapbp, $sgaps, $sgapbp, $subj) = @{ $x{$topscore}{$line} };
		if ($mostgaps || $leastgaps) {
		    my $agapbp = $qgapbp+$sgapbp;
		    $bestgaps{$agapbp}{$line} = $subj;
		} else {
		    $bestgaps{$line} = $subj;
		}
	    }
	    
	    ## after gap filtering, choose the least/most-gapped alignments among the candidates (or not)
	    
	    if ($leastgaps) {
		my $minGapBp = (sort {$a <=> $b} keys %bestgaps)[0];
		warn "No alignments left!!  $query, $topscore, $minGapBp\n" unless scalar (keys %{ $bestgaps{$minGapBp} });
		foreach my $line (keys %{ $bestgaps{$minGapBp} }) {
		    print $OUT "$line\n";
		    $postbest{$query} = 1;
		    $bestS{ $bestgaps{$minGapBp}{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    } elsif ($mostgaps) {
		my $maxGapBp = (sort {$b <=> $a} keys %bestgaps)[0];
		foreach my $line (keys %{ $bestgaps{$maxGapBp} }) {
		    print $OUT "$line\n";
		    $bestS{ $bestgaps{$maxGapBp}{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    } else {
		foreach my $line (keys %bestgaps) {
		    print $OUT "$line\n";
		    $bestS{ $bestgaps{$line} } = 1;   # best-alignment subjects
		    $bestaln++;
		}
	    }
#		    foreach my $line (keys %{ $x{$topscore} }) {
#			print $OUT "$line\n";
#			$bestS{ $x{$topscore}{$line}->[4] } = 1;   # best-alignment subjects
#			$bestaln++;
#		    }
	}
    }
}




